a type "
"<literal>Date</literal> or <literal>Timestamp</literal> of the persistent "
"class."
msgstr ""
"<literal>name</literal>: 영속 클래스에 대해 자바 <literal>Date</literal> 또"
"는 <literal>Timestamp</literal> 타입을 가진 자바빈즈 스타일의 프로퍼티 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>null</"
"literal>): a version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. <literal>Undefined</literal> "
"specifies that the identifier property value should be used."
msgstr ""
"<literal>unsaved-value</literal> (옵션 - 디폴트는 <literal>null</literal>): "
"이전 세션에서 저장되었거나 로드되었던 detached 인스턴스로부터 인스턴스를 구별"
"지우는, 인스턴스가 새로이 초기화됨(unsaved)을 나타내는 version 프로퍼티 값."
"(<literal>undefined</literal>는 식별자 프로퍼티 값이 사용될 것임을 지정한다.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>source</literal> (optional - defaults to <literal>vm</literal>): "
"Where should Hibernate retrieve the timestamp value from? From the database, "
"or from the current JVM? Database-based timestamps incur an overhead because "
"Hibernate must hit the database in order to determine the \"next value\". It "
"is safer to use in clustered environments. Not all <literal>Dialects</"
"literal> are known to support the retrieval of the database's current "
"timestamp. Others may also be unsafe for usage in locking due to lack of "
"precision (Oracle 8, for example)."
msgstr ""
"<literal>source</literal> (옵션 - 디폴트는 <literal>vm</literal>): Hibernate"
"는 어디서 timestamp 값을 검색할 것인가? 데이터베이스로부터인가 현재의 JVM으로"
"부터인가? 데이터베이스 기반의 timestamp들은 Hibernate가 \"다음 값\"을 결정하"
"기 위해 데이터베이스에 접속해야 하기 때문에 오버헤드를 초래하지만, 클러스터링"
"된 환경들에서의 용도로 보다 더 안전할 것이다. 또한 모든 <literal>Dialect</"
"literal>들이 데이터베이스의 현재의 timestamp에 대한 검색을 지원하는 것으로 알"
"려져 있지 않지만, 다른 <literal>Dialect</literal>들은 정밀도 결핍 때문에 잠금"
"에 있어 사용이 안전하지 않을 수 있음을 노트하라(예를 들면 오라클 8)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this timestamp property value is actually "
"generated by the database. See the discussion of <link linkend=\"mapping-"
"generated\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal> (옵션 - 디폴트는 <literal>never</literal>): 이 "
"timestamp 프로퍼티 값이 데이터베이스에 의해 실제로 생성됨을 지정한다. <xref "
"linkend=\"mapping-generated\">산출되는 프로퍼티들</xref>에 대한 논의들 보라."

#. Tag: title
#, no-c-format
msgid "Note"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version "
"type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db"
"\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
"\"&gt;</literal>"
msgstr ""
"<literal>&lt;timestamp&gt;</literal>는 <literal>&lt;version type=\"timestamp"
"\"&gt;</literal>과 같음을 노트하라. 그리고 <literal>&lt;timestamp use-db="
"\"true\"&gt;</literal>는 <literal>&lt;version type=\"dbtimestamp\"&gt;</"
"literal>과 같다"

#. Tag: title
#, fuzzy, no-c-format
msgid "Property"
msgstr "프로퍼티"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;property&gt;</literal> element declares a persistent "
"JavaBean style property of the class."
msgstr ""
"<literal>&lt;property&gt;</literal> 요소는 클래스의 자바빈즈 스타일의 영속 프"
"로퍼티를 선언한다."

#. Tag: para
#, no-c-format
msgid ""
"<literal>name</literal>: the name of the property, with an initial lowercase "
"letter."
msgstr "<literal>name</literal>: 첫 소문자로 시작하는 프로퍼티 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the mapped database table column. This can also be specified by "
"nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""
"<literal>column</literal> (옵션 - 디폴트는 프로퍼티 이름): 매핑된 데이터베이"
"스 테이블 컬럼의 이름. 이것은 또한 내부에 포함되는 <literal>&lt;column&gt;</"
"literal> 요소(들)에 의해 지정될 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>): specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" property "
"whose value is initialized from some other property that maps to the same "
"column(s), or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal> (옵션 - 디폴트는 <literal>true</"
"literal>) : 매핑된 컬럼들이 <literal>UPDATE</literal>와/또는 "
"<literal>INSERT</literal> 문장들속에 포함될 것임을 지정한다. 둘다 "
"<literal>false</literal>로 설정하는 것은 그 값이 동일한 컬럼(들)로 매핑되는 "
"어떤 다른 프로퍼티로부터 또는 트리거에 의해 또는 다른 어플리케이션으로부터 초"
"기화 되는 순수하게 \"파생된(derived)\" 프로퍼티를 허용해준다."

#. Tag: para
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> property. Computed properties do "
"not have a column mapping of their own."
msgstr ""
"<literal>formula</literal> (옵션): <emphasis>계산되는</emphasis> 프로퍼티에 "
"대해 값을 정의하는 SQL 표현식. 계산되는 프로퍼티들은 그것들 자신에 대한 컬럼 "
"매핑을 갖지 않는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"specifies that this property should be fetched lazily when the instance "
"variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>false</literal>): 인스턴스 "
"변수가 처음으로 액세스 될 때 이 프로퍼티가 lazily하게 페치될 것임을 지정한다"
"(빌드-시 바이트코드 수단을 필요로 한다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional): enables the DDL generation of a unique "
"constraint for the columns. Also, allow this to be the target of a "
"<literal>property-ref</literal>."
msgstr ""
"<literal>unique</literal> (옵션): 컬럼들에 대한 유일 컨스트레인트의 DDL 생성"
"을 가능하게 만든다. 또한 이것이 <literal>property-ref</literal>의 타켓이 되"
"는 것을 허용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-null</literal> (optional): enables the DDL generation of a "
"nullability constraint for the columns."
msgstr ""
"<literal>not-null</literal> (옵션): 컬럼들에 대해 null 가능 컨스트레인트의 "
"DDL 생성을 가능하게 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this property do or do not require "
"acquisition of the optimistic lock. In other words, it determines if a "
"version increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이 프로퍼티에 대한 업데이트들이 optimistic 잠금을 획득하는 것을 필"
"요로 하거나 필요로 하지 않음을 지정한다. 달리말해, 이 프로퍼티가 dirty일 때 "
"버전 증가가 발생할 경우인지를 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this property value is actually generated by the "
"database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal> (옵션 - 디폴트는 <literal>never</literal>): 이 "
"프로퍼티 값이 데이터베이스에 의해 실제로 산출되는지를 지정한다. <xref "
"linkend=\"mapping-generated\">산출되는 프로퍼티들</xref>에 대한 논의를 보라."

#. Tag: para
#, no-c-format
msgid "<emphasis>typename</emphasis> could be:"
msgstr "<emphasis>typename</emphasis>은 다음일 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The name of a Hibernate basic type: <literal>integer, string, character, "
"date, timestamp, float, binary, serializable, object, blob</literal> etc."
msgstr ""
"Hibernate 기본 타입의 이름 (예를 들어. <literal>integer, string, character, "
"date, timestamp, float, binary, serializable, object, blob</literal>)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The name of a Java class with a default basic type: <literal>int, float, "
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal> etc."
msgstr ""
"디폴트 기본 타입을 가진 Java 클래스의 이름(예를 들어. <literal>int, float, "
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal>)."

#. Tag: para
#, no-c-format
msgid "The name of a serializable Java class."
msgstr "serializable Java 클래스의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The class name of a custom type: <literal>com.illflow.type.MyCustomType</"
"literal> etc."
msgstr ""
"맞춤 타입의 클래스 이름(예를 들어. <literal>com.illflow.type.MyCustomType</"
"literal>)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you do not specify a type, Hibernate will use reflection upon the named "
"property and guess the correct Hibernate type. Hibernate will attempt to "
"interpret the name of the return class of the property getter using, in "
"order, rules 2, 3, and 4. In certain cases you will need the <literal>type</"
"literal> attribute. For example, to distinguish between <literal>Hibernate."
"DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a "
"custom type."
msgstr ""
"만일 당신이 타입을 지정하지 않을 경우, Hibernate는 정확한 Hibernate 타입을 추"
"정하기 위해 명명된 프로퍼티에 대해 reflection을 사용할 것이다. Hibernate는 "
"그 순서에서 2,3,4 규칙들을 사용하여 프로퍼티 getter의 반환 클래스의 이름을 해"
"석하려고 시도할 것이다. 하지만 이것은 항상 충분하지는 않다. 어떤 경우들에서, "
"당신은 여전히 <literal>type</literal> 속성을 필요로 할 것이다.(예를 들어, "
"<literal>Hibernate.DATE</literal>와 <literal>Hibernate.TIMESTAMP</literal> 사"
"이를 구별하기 위해, 또는 맞춤 타입을 지정하기 위해.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>access</literal> attribute allows you to control how Hibernate "
"accesses the property at runtime. By default, Hibernate will call the "
"property get/set pair. If you specify <literal>access=\"field\"</literal>, "
"Hibernate will bypass the get/set pair and access the field directly using "
"reflection. You can specify your own strategy for property access by naming "
"a class that implements the interface <literal>org.hibernate.property."
"PropertyAccessor</literal>."
msgstr ""
"<literal>access</literal> 속성은 당신으로 하여금 Hibernate가 런타임 시에 프로"
"퍼티에 액세스하는 방법을 제어하도록 해준다. 디폴트로 Hibernate는 프로퍼티 "
"get/set 쌍을 호출할 것이다. 만일 당신이 <literal>access=\"field\"</literal>"
"를 지정할 경우, Hibernate는 get/set 쌍을 피하고 reflection을 사용하여 직접 필"
"드에 액세스 할 것이다. 당신은 <literal>org.hibernate.property."
"PropertyAccessor</literal> 인터페이스를 구현하는 클래스를 명명함으로써 프로퍼"
"티 접근을 위한 당신 자신의 방도를 지정할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A powerful feature is derived properties. These properties are by definition "
"read-only. The property value is computed at load time. You declare the "
"computation as an SQL expression. This then translates to a <literal>SELECT</"
"literal> clause subquery in the SQL query that loads an instance:"
msgstr ""
"특별히 강력한 특징은 파생된 플로퍼티들이다. 이들 프로퍼티들은 정의상 읽기 전"
"용이고, 그 프로퍼티 값은 로드 시에 계산된다. 당신은 그 계산을 SQL 표현식으로 "
"선언하고, 이것은 인스턴스를 로드시키는 SQL 질의 내의 <literal>SELECT</"
"literal> 절 서브질의로 번역된다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can reference the entity table by not declaring an alias on a particular "
"column. This would be <literal>customerId</literal> in the given example. "
"You can also use the nested <literal>&lt;formula&gt;</literal> mapping "
"element if you do not want to use the attribute."
msgstr ""
"당신은 특정 컬럼(주어진 예제에서는 <literal>customerId</literal>)에 대해 "
"alias를 선언하지 않음으로써 엔티티들 자신의 테이블을 참조할 수 있음을 노트하"
"라. 또한 당신은 만일 당신이 그 속성을 사용하고 싶지 않을 경우에 내포된 "
"<literal>&lt;formula&gt;</literal> 매핑 요소를 사용할 수 있음을 노트하라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Many-to-one"
msgstr "many-to-one"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An ordinary association to another persistent class is declared using a "
"<literal>many-to-one</literal> element. The relational model is a many-to-"
"one association; a foreign key in one table is referencing the primary key "
"column(s) of the target table."
msgstr ""
"또 다른 영속 클래스에 대한 정규 연관관계는 <literal>many-to-one</literal> 요"
"소를 사용하여 선언된다. 관계형 모형은 many-to-one 연관관계이다.: 하나의 테이"
"블 내에 있는 foreign 키는 대상 테이블의 프라이머리 키 컬럼(들)을 참조하고 있"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>name</literal>: the name of the property."
msgstr "<literal>name</literal>: 프로퍼티의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional): the name of the foreign key column. "
"This can also be specified by nested <literal>&lt;column&gt;</literal> "
"element(s)."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>column</literal> (옵션): foreign key 컬럼의 이름. 이것은 또한 내포"
"된 <literal>&lt;column&gt;</literal> 요소(들)에 의해 지정된다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>column</literal> (옵션): foreign key 컬럼의 이름. 이것은 또한 내포"
"된 <literal>&lt;column&gt;</literal> 요소(들)에 의해 지정될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the name of the associated class."
msgstr ""
"<literal>class</literal> (옵션 - 디폴트는 reflection에 의해 결정된 프로퍼티 "
"타입): 연관된 클래스의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>cascade</literal> (optional): specifies which operations should be "
"cascaded from the parent object to the associated object."
msgstr ""
"<literal>cascade</literal> (옵션) 어느 오퍼레이션들이 부모 객체로부터 연관된 "
"객체로 케스케이드 될 것인지를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>select</literal>): "
"chooses between outer-join fetching or sequential select fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>fetch</literal> (옵션 - 디폴트는 <literal>select</literal>): outer-"
"join 페칭 또는 sequential select 페칭 사이에서 선택하라.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>fetch</literal> (옵션 - 디폴트는 <literal>select</literal>): outer-"
"join 페칭 또는 순차적인 select 페칭 중에서 선택하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>): specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" "
"association whose value is initialized from another property that maps to "
"the same column(s), or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal> (옵션 - 디폴트는 <literal>true</literal>) "
"매핑된 컬럼들이 SQL <literal>UPDATE</literal>와/또는 <literal>INSERT</"
"literal> 문장들 속에 포함될 것인지를 지정한다. 둘다 <literal>false</literal>"
"로 설정하는 것은 그 값이 동일한 컬럼(들)로 매핑시키는 어떤 다른 컬럼들로부터 "
"초기화 되거나 트리거나 다른 어플리케이션에 의해 초기화되는 단순한 \"파생된\" "
"연관관계 값을 허용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): the name of a property of the "
"associated class that is joined to this foreign key. If not specified, the "
"primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>: (옵션) 이 foreign key에 조인되는 연관된 클래"
"스의 프로퍼티 이름. 지정되지 않을 경우, 연관 클래스의 프라이머리 키가 사용된"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional): enables the DDL generation of a unique "
"constraint for the foreign-key column. By allowing this to be the target of "
"a <literal>property-ref</literal>, you can make the association multiplicity "
"one-to-one."
msgstr ""
"<literal>unique</literal> (옵션): foreign-key 컬럼을 위한 유일 컨스트레인트"
"의 DDL 생성을 가능하도록 해준다. 또한 이것이 property-ref의 대상이 되는 것을 "
"허용해준다. 이것은 연관 다중성(association multiplicity)을 효율적으로 일 대 "
"일로 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-null</literal> (optional): enables the DDL generation of a "
"nullability constraint for the foreign key columns."
msgstr ""
"<literal>not-null</literal> (옵션): foreign key 컬럼들을 위한 null 가능한 컨"
"스트레인트의 DDL 생성을 가능하도록 해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"by default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed. This requires build-time bytecode "
"instrumentation. <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>proxy</literal>): 디폴트"
"로, 단일 포인트 연관들이 프락시된다. <literal>lazy=\"no-proxy\"</literal>는 "
"인스턴스 변수가 처음으로 접근될 때 그 프로퍼티가 lazily 페치될 것임을 지정한"
"다(빌드-시 바이트코드 수단을 필요로 한다). <literal>lazy=\"false\"</literal>"
"는 그 연관이 항상 eagerly 페치될 것임을 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-found</literal> (optional - defaults to <literal>exception</"
"literal>): specifies how foreign keys that reference missing rows will be "
"handled. <literal>ignore</literal> will treat a missing row as a null "
"association."
msgstr ""
"<literal>not-found</literal> (옵션 - 디폴트는 <literal>exception</literal>): "
"누락된 행들을 참조하는 foreign key들이 어떻게 처리될 것인지를 지정한다: "
"<literal>ignore</literal>는 한 개의 누락된 행을 한 개의 null 연관으로 취급할 "
"것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>entity-name</literal> (optional): the entity name of the associated "
"class."
msgstr "<literal>entity-name</literal> (옵션): 연관된 클래스의 엔티티 이름."

#. Tag: para
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> foreign key."
msgstr ""
"<literal>formula</literal> (옵션): <emphasis>계산된</emphasis> foreign key에 "
"대한 값을 정의하는 SQL 표현식."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Setting a value of the <literal>cascade</literal> attribute to any "
"meaningful value other than <literal>none</literal> will propagate certain "
"operations to the associated object. The meaningful values are divided into "
"three categories. First, basic operations, which include: <literal>persist, "
"merge, delete, save-update, evict, replicate, lock and refresh</literal>; "
"second, special values: <literal>delete-orphan</literal>; and third,"
"<literal>all</literal> comma-separated combinations of operation names: "
"<literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,"
"delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\" /> "
"for a full explanation. Note that single valued, many-to-one and one-to-one, "
"associations do not support orphan delete."
msgstr ""
"<literal>cascade</literal> 속성 값을 <literal>none</literal> 아닌 어떤 의미있"
"는 다른 값으로 설정하는 것은 어떤 오퍼레이션들을 연관된 객체에게 보급할 것이"
"다. 유의미한 값들은 Hibernate의 기본 오퍼레이션들의 이름들, 즉 "
"<literal>persist, merge, delete, save-update, evict, replicate, lock, "
"refresh</literal> 뿐만 아니라 특별한 값들, 즉 <literal>delete-orphan</"
"literal>과 <literal>all</literal> 그리고 오퍼레이션 이름들의 쉼표 분리된 조합"
"들, 예를 들면 <literal>cascade=\"persist,merge,evict\"</literal> 또는 "
"<literal>cascade=\"all,delete-orphan\"</literal>이다. 전체 설명은 <xref "
"linkend=\"objectstate-transitive\"/>를 보라. 단일값 연관들(many-to-one 연관"
"과 one-to-one 연관)은 orphan delete를 지원하지 않음을 노트하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Here is an example of a typical <literal>many-to-one</literal> declaration:"
msgstr ""
"일반적인 <literal>many-to-one</literal> 선언은 다음과 같이 간단하게 보여진다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>property-ref</literal> attribute should only be used for "
"mapping legacy data where a foreign key refers to a unique key of the "
"associated table other than the primary key. This is a complicated and "
"confusing relational model. For example, if the <literal>Product</literal> "
"class had a unique serial number that is not the primary key. The "
"<literal>unique</literal> attribute controls Hibernate's DDL generation with "
"the SchemaExport tool."
msgstr ""
"<literal>property-ref</literal> 속성은 오직 foreign key가 프라이머리 키가 아"
"닌 연관된 테이블의 유일 키를 참조하는 리거시 데이터를 매핑하는데만 사용된다. "
"이것은 꼴사나운 관계형 모형이다. 예를 들어, <literal>Product</literal> 클래스"
"가 프라이머리 키를 아닌, 유일한 시리얼 번호를 갖는다고 가정하자."
"(<literal>unique</literal> 속성은 SchemaExport 도구로 Hibernate의 DDL 생성을 "
"제어한다.)"

#. Tag: para
#, no-c-format
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr ""
"그런 다음 <literal>OrderItem</literal>에 대한 매핑은 다음을 사용할 것이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid "This is not encouraged, however."
msgstr "하지만 이것은 확실히 권장되지 않는다."

#. Tag: para
#, no-c-format
msgid ""
"If the referenced unique key comprises multiple properties of the associated "
"entity, you should map the referenced properties inside a named <literal>&lt;"
"properties&gt;</literal> element."
msgstr ""
"만일 참조된 유일 키가 연관된 엔티티의 여러 프로퍼티들을 포함할 경우, 당신은 "
"명명된 <literal>&lt;properties&gt;</literal> 요소 내부에 참조된 프로퍼티들을 "
"매핑할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If the referenced unique key is the property of a component, you can specify "
"a property path:"
msgstr ""
"만일 참조된 유일키가 컴포넌트의 프로퍼티일 경우, 당신은 하나의 프로퍼티 경로"
"를 지정할 수 있다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "One-to-one"
msgstr "one-to-one"

#. Tag: para
#, no-c-format
msgid ""
"A one-to-one association to another persistent class is declared using a "
"<literal>one-to-one</literal> element."
msgstr ""
"또 다른 영속 클래스에 대한 one-to-one 연관관계는 <literal>one-to-one</"
"literal> 요소를 사용하여 선언된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>constrained</literal> (optional): specifies that a foreign key "
"constraint on the primary key of the mapped table and references the table "
"of the associated class. This option affects the order in which <literal>save"
"()</literal> and <literal>delete()</literal> are cascaded, and determines "
"whether the association can be proxied. It is also used by the schema export "
"tool."
msgstr ""
"<literal>constrained</literal> (옵션) 매핑된 테이블의 프라이머리 키에 대한 "
"foreign 키 컨스트레인트가 연관된 클래스의 테이블을 참조하는지 여부를 지정한"
"다. 이 옵션은 <literal>save()</literal>와 <literal>delete()</literal>가 케스"
"케이드 되는 순서에 영향을 주고, 그 연관이 프락시 될 것인지 여부를 결정한다 "
"(또한 스키마 내보내기 도구에 의해 사용된다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): the name of a property of the "
"associated class that is joined to the primary key of this class. If not "
"specified, the primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>: (옵션) 이 클래스의 프라이머리 키에 연결된 연"
"관 클래스의 프로퍼티의 이름. 만일 지정되지 않을 경우, 연관 클래스의 프라이머"
"리 키가 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>formula</literal> (optional): almost all one-to-one associations "
"map to the primary key of the owning entity. If this is not the case, you "
"can specify another column, columns or expression to join on using an SQL "
"formula. See <literal>org.hibernate.test.onetooneformula</literal> for an "
"example."
msgstr ""
"<literal>formula</literal> (옵션): 거의 모든 one to one 연관관계들은 소유하"
"는 엔티티의 프라이머리 키로 매핑된다. 이것이 그 경우가 아닌 드문 경우들에서, "
"당신은 SQL formula 사용에 결합시킬 몇몇 다른 컬럼, 컬럼들, 또는 표현식을 지정"
"할 수 있다.(예제는 <literal>org.hibernate.test.onetooneformula</literal>를 보"
"라.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"by default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed. It requires build-time bytecode "
"instrumentation. <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched. <emphasis>Note that if "
"<literal>constrained=\"false\"</literal>, proxying is impossible and "
"Hibernate will eagerly fetch the association</emphasis>."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>proxy</literal>): 디폴트로 "
"한쪽 끝 연관들이 프락시 된다. <literal>lazy=\"no-proxy\"</literal>는 인스턴"
"스 변수가 처음 접근될 때 그 프로퍼티가 lazily 페치될 것임을 지정한다(빌드-시 "
"바이트코드 수단을 필요로 한다). <literal>lazy=\"false\"</literal>는 그 연관들"
"이 항상 eagerly 페치될 것임을 지정한다. <emphasis>만일 <literal>constrained="
"\"false\"</literal>인 경우에, 프락싱은 불가능하고 Hibernate는 그 연관을 "
"eager 페치시킬 것이다!</emphasis>"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are two varieties of one-to-one associations:"
msgstr "one-to-one 연관관계에는 두 가지 변종이 존재한다:"

#. Tag: para
#, no-c-format
msgid "primary key associations"
msgstr "프라이머리 키 연관관계들"

#. Tag: para
#, no-c-format
msgid "unique foreign key associations"
msgstr "유일 foreign 키 연관관계들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Primary key associations do not need an extra table column. If two rows are "
"related by the association, then the two table rows share the same primary "
"key value. To relate two objects by a primary key association, ensure that "
"they are assigned the same identifier value."
msgstr ""
"프라이머리 키 연관들은 특별한 테이블 컬럼을 필요로 하지 않는다; 만일 두 개의 "
"행들이 그 연관에 의해 관계지워지면, 두 개의 테이블 행들은 동일한 프라이머리 "
"키 값을 공유한다. 따라서 만일 두 개의 객체들이 프라이머리 키 연관에 의해 관계"
"지워지도록 당신이 원할 경우, 당신은 그것들에 동일한 식별자 값이 할당되도록 해"
"야 한다!"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For a primary key association, add the following mappings to "
"<literal>Employee</literal> and <literal>Person</literal> respectively:"
msgstr ""
"프라이머리 키 연관에 대해, 다음 매핑들을 <literal>Employee</literal>와 "
"<literal>Person</literal> 각각에 추가하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE "
"tables are equal. You use a special Hibernate identifier generation strategy "
"called <literal>foreign</literal>:"
msgstr ""
"이제 우리는 PERSON 과 EMPLOYEE 테이블들에서 관계지워진 행들의 프라이머리 키들"
"이 동일함을 확실히 해야 한다! 우리는 <literal>foreign</literal>로 명명되는 특"
"별한 Hibernate 식별자 생성 방도를 사용한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A newly saved instance of <literal>Person</literal> is assigned the same "
"primary key value as the <literal>Employee</literal> instance referred with "
"the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr ""
"그때 <literal>Person</literal>의 새로이 저장된 인스턴스는 그 "
"<literal>Person</literal>의 <literal>employee</literal> 프로퍼티에 대해 참조"
"된 <literal>Employee</literal> 인스턴스와 동일한 프라이머리 키를 할당받는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, a foreign key with a unique constraint, from "
"<literal>Employee</literal> to <literal>Person</literal>, can be expressed "
"as:"
msgstr ""
"달리, <literal>Employee</literal>로부터 <literal>Person</literal>으로의 유일 "
"컨스트레인트를 가진 하나의 foreign key는 다음과 같이 표현될 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This association can be made bidirectional by adding the following to the "
"<literal>Person</literal> mapping:"
msgstr ""
"그리고 이 연관은 다음을 <literal>Person</literal> 매핑에 추가함으로써 양방향"
"이 될 수 있다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "Natural-id"
msgstr "natural-id"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Although we recommend the use of surrogate keys as primary keys, you should "
"try to identify natural keys for all entities. A natural key is a property "
"or combination of properties that is unique and non-null. It is also "
"immutable. Map the properties of the natural key inside the <literal>&lt;"
"natural-id&gt;</literal> element. Hibernate will generate the necessary "
"unique key and nullability constraints and, as a result, your mapping will "
"be more self-documenting."
msgstr ""
"비록 우리가 프라이머리 키들로서 대용키들을 사용하는 것을 권장했을지라도, 당신"
"은 여전히 모든 엔티티들에 대한 natural 키들을 식별하고자 원할 것이다. "
"narutal 키는 유일(unique)하고 null이 아닌 프로퍼티 또는 프로퍼티들의 조합이"
"다. 그것이 또한 불변하는 것일 경우가 더 좋다. <literal>&lt;natural-id&gt;</"
"literal> 요소 내부에 있는 natural 키의 프로퍼티들을 매핑하라. Hibernate는 필"
"수적인 유일 키와 null 허용가능한 컨스트레인트들을 생성시킬 것이고, 당신의 매"
"핑은 보다 자가 설명적이게 될 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is recommended that you implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> to compare the natural key properties of the "
"entity."
msgstr ""
"우리는 당신이 엔티티에 대한 narutal 키 프로퍼티들을 비교하는데 "
"<literal>equals()</literal>와 <literal>hashCode()</literal>를 구현할 것을 강"
"력하게 권장한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This mapping is not intended for use with entities that have natural primary "
"keys."
msgstr ""
"이 매핑은 natural 프라이머리 키들을 가진 엔티티들을 위한 용도로 고안된 것은 "
"아니다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>mutable</literal> (optional - defaults to <literal>false</"
"literal>): by default, natural identifier properties are assumed to be "
"immutable (constant)."
msgstr ""
"<literal>mutable</literal> (옵션, 디폴트는 <literal>false</literal>): 디폴트"
"로, narutal 식별자 프로퍼티들은 변경될 수 없는 것(상수)으로 가정된다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Component and dynamic-component"
msgstr "component, dynamic-component"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element maps properties of a child "
"object to columns of the table of a parent class. Components can, in turn, "
"declare their own properties, components or collections. See the \"Component"
"\" examples below:"
msgstr ""
"<literal>&lt;component&gt;</literal> 요소는 자식 객체의 프로퍼티들을 부모 클"
"래스에 대한 테이블의 컬럼들로 매핑시킨다. 컴포넌트들은 그것들 자신의 프로퍼티"
"들, 컴포넌트들, 또는 콜렉션들을 선언한다. 이래 \"컴포넌트들\"을 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the name of the component (child) class."
msgstr ""
"<literal>class</literal> (옵션 - 디폴트는 reflection에 의해 결정된 프로퍼티 "
"타입): 컴포넌트(자식) 클래스의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>insert</literal>: do the mapped columns appear in SQL "
"<literal>INSERTs</literal>?"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>insert</literal>: 매핑된 컬럼들이 SQL <literal>INSERT</literal>들 속"
"에 나타나야 하는가?\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>insert</literal>: 매핑된 컬럼들이 SQL <literal>INSERT</literal>들 내"
"에 나타날 것인가?"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update</literal>: do the mapped columns appear in SQL "
"<literal>UPDATEs</literal>?"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>update</literal>: 매핑된 컬럼들이 SQL <literal>UPDATE</literal>들 속"
"에 나타나야 하는가?\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>update</literal>: 매핑된 컬럼들이 SQL <literal>UPDATE</literal>들 내"
"에 나타날 것인가?"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"specifies that this component should be fetched lazily when the instance "
"variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>false</literal>): 인스턴스 "
"변수가 처음으로 액세스될 때 이 컴포넌트가 lazily(느리게) 페치되어야 하는지 여"
"부를 지정한다 (빌드 시 바이트코드 수단을 필요로 한다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this component either do or do not "
"require acquisition of the optimistic lock. It determines if a version "
"increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이 컴포넌트에 대한 업데이트들이 optimistic 잠금을 획득하는 것을 필"
"요로 하는지 여부를 지정한다. 달리 말해 이 프로퍼티가 dirty 일 때 버전 증가가 "
"발생할 것인지 여부를 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
"specifies that a unique constraint exists upon all mapped columns of the "
"component."
msgstr ""
"<literal>unique</literal> (옵션 - 디폴트는 <literal>false</literal>): 유일 컨"
"스트레인트가 컴포넌트의 모든 매핑된 컬럼들에 대해 존재하는지 여부를 지정한다."

#. Tag: para
#, no-c-format
msgid ""
"The child <literal>&lt;property&gt;</literal> tags map properties of the "
"child class to table columns."
msgstr ""
"자식 <literal>&lt;property&gt;</literal> 태그들은 자식 클래스의 프로퍼티들을 "
"테이블 컬럼들로 매핑시킨다."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
"parent&gt;</literal> subelement that maps a property of the component class "
"as a reference back to the containing entity."
msgstr ""
"<literal>&lt;component&gt;</literal> 요소는 컴포넌트 클래스의 프로퍼티를 포함"
"하는 엔티티에 대한 참조로서 매핑시키는 <literal>&lt;parent&gt;</literal> 서브"
"요소를 허용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;dynamic-component&gt;</literal> element allows a "
"<literal>Map</literal> to be mapped as a component, where the property names "
"refer to keys of the map. See <xref linkend=\"components-dynamic\" /> for "
"more information."
msgstr ""
"<literal>&lt;dynamic-component&gt;</literal> 요소는 컴포넌트로서 매핑될"
"<literal>Map</literal>을 허용한다. 여기서 프로퍼티 이름들은 map의 키들을 참조"
"한다. <xref linkend=\"components-dynamic\"/>을 보라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Properties"
msgstr "properties"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;properties&gt;</literal> element allows the definition of a "
"named, logical grouping of the properties of a class. The most important use "
"of the construct is that it allows a combination of properties to be the "
"target of a <literal>property-ref</literal>. It is also a convenient way to "
"define a multi-column unique constraint. For example:"
msgstr ""
"<literal>&lt;properties&gt;</literal> 요소는 클래스의 프로퍼티들의 명명된, 논"
"리적 그룹핑에 대한 정의를 허용한다. 그 구조에 대한 가장 중요한 사용은 그것이 "
"프로퍼티들의 조합이 <literal>property-ref</literal>의 대상이 되는 것을 허용해"
"준다는 점이다. 또한 그것은 다중 컬럼 유일 컨스트레인느를 정의하는 편리한 방법"
"이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal>: the logical name of the grouping. It is "
"<emphasis>not</emphasis> an actual property name."
msgstr ""
"<literal>name</literal>: 그룹핑의 논리적 이름 - 실제 프로퍼티 이름이 "
"<emphasis>아니다</emphasis>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to these properties either do or do not "
"require acquisition of the optimistic lock. It determines if a version "
"increment should occur when these properties are dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이들 프로퍼티들에 대한 업데이트들이 optimistic 잠금의 획득을 필요"
"로 하는지 여부를 지정한다. 달리 말해 이 프로퍼티가 dirty 일 때 버전 증가가 발"
"생할 것인지 여부를 결정한다."

#. Tag: para
#, no-c-format
msgid ""
"For example, if we have the following <literal>&lt;properties&gt;</literal> "
"mapping:"
msgstr ""
"예를 들어, 만일 우리가 다음 <literal>&lt;properties&gt;</literal> 매핑을 가"
"질 경우:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You might have some legacy data association that refers to this unique key "
"of the <literal>Person</literal> table, instead of to the primary key:"
msgstr ""
"그 때 우리는 프라이머리 키가 아닌, <literal>Person</literal> 테이블의 이 유"
"일 키를 참조하는 어떤 리거시 데이터 연관을 가질 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The use of this outside the context of mapping legacy data is not "
"recommended."
msgstr ""
"우리는 리거시 데이터를 매핑시키는 컨텍스트 바깥에서 이런 종류의 것을 사용하"
"는 것을 권장하지 않는다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Subclass"
msgstr "subclass"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Polymorphic persistence requires the declaration of each subclass of the "
"root persistent class. For the table-per-class-hierarchy mapping strategy, "
"the <literal>&lt;subclass&gt;</literal> declaration is used. For example:"
msgstr ""
"마지막으로, 다형성 영속성은 루트 영속 클래스에 대한 각각의 서브클래스 선언을 "
"필요로 한다.(권장되는) table-per-class-hierarchy(테이블 당 클래스 계층구조) "
"매핑 방도의 경우, <literal>&lt;subclass&gt;</literal> 선언이 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal>: the fully qualified class name of the subclass."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>name</literal>: 서브클래스의 전체 수식어가 붙은 클래스 이름.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>name</literal>: 서브클래스의 전체 수식어가 붙은 클래스 명.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>name</literal>: 서브클래스의 전체 수식어가 붙은 클래스 명."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): a value that distinguishes individual subclasses."
msgstr ""
"<literal>discriminator-value</literal> (옵션 - 디폴트는 클래스 이름): 개개의 "
"서브클래스들을 구분짓는 값."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies a class or interface used for "
"lazy initializing proxies."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): lazy 초기화 프락시들을 사용하는데 클래스 또"
"는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
"setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭의 사용을 불가능하게 만든"
"다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Each subclass declares its own persistent properties and subclasses. "
"<literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> "
"properties are assumed to be inherited from the root class. Each subclass in "
"a hierarchy must define a unique <literal>discriminator-value</literal>. If "
"this is not specified, the fully qualified Java class name is used."
msgstr ""
"각각의 서브클래스는 그것 자신의 영속 프로퍼티들과 서브클래스들을 선언할 것이"
"다. <literal>&lt;version&gt;</literal> 프로퍼티와 <literal>&lt;id&gt;</"
"literal> 프로퍼티는 루트 클래스로부터 상속된다고 가정된다. 계층구조 내에서 각"
"각의 서브클래스는 유일한 <literal>discriminator-value</literal>를 정의해야 한"
"다. none이 지정될 경우, 전체 수식어가 붙은 자바 클래스 이름이 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For information about inheritance mappings see <xref linkend=\"inheritance"
"\" />."
msgstr "상속 매핑들에 대한 정보는 <xref linkend=\"inheritance\"/>을 보라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Joined-subclass"
msgstr "joined-subclass"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Each subclass can also be mapped to its own table. This is called the table-"
"per-subclass mapping strategy. An inherited state is retrieved by joining "
"with the table of the superclass. To do this you use the <literal>&lt;joined-"
"subclass&gt;</literal> element. For example:"
msgstr ""
"다른 방법으로 각각의 서브클래스는 그것 자신이 테이블로 매핑될 수 있다(table-"
"per-subclass 매핑 방도). 상속된 상태는 슈퍼클래스의 테이블과 조인함으로써 검"
"색된다. 우리는 <literal>&lt;joined-subclass&gt;</literal> 요소를 사용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>table</literal>: the name of the subclass table."
msgstr "<literal>table</literal>: 서브클래스 테이블의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies a class or interface to use "
"for lazy initializing proxies."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): lazy 초기화 프락시들을 사용하는데 클래스 또"
"는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
"setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭의 사용을 불가능하게 만든"
"다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A discriminator column is not required for this mapping strategy. Each "
"subclass must, however, declare a table column holding the object identifier "
"using the <literal>&lt;key&gt;</literal> element. The mapping at the start "
"of the chapter would then be re-written as:"
msgstr ""
"판별자(discriminator) 컬럼은 이 매핑 방도에 필요하지 않다. 하지만 각각의 서브"
"클래스는 <literal>&lt;key&gt;</literal> 요소를 사용하여 객체 식별자를 보관하"
"는 테이블 컬럼을 선언해야 한다. 이 장의 시작 부분에 있는 매핑은 다음과 같이 "
"다시 작성될 것이다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "Union-subclass"
msgstr "union-subclass"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A third option is to map only the concrete classes of an inheritance "
"hierarchy to tables. This is called the table-per-concrete-class strategy. "
"Each table defines all persistent states of the class, including the "
"inherited state. In Hibernate, it is not necessary to explicitly map such "
"inheritance hierarchies. You can map each class with a separate <literal>&lt;"
"class&gt;</literal> declaration. However, if you wish use polymorphic "
"associations (e.g. an association to the superclass of your hierarchy), you "
"need to use the <literal>&lt;union-subclass&gt;</literal> mapping. For "
"example:"
msgstr ""
"제3의 옵션은 상속 계층구조의 concrete 클래스들 만을 테이블들로 매핑하는 것이"
"다 (table-per-concrete-class 방도). 여기서 각각의 테이블은 상속된 상태를 포함"
"하여 클래스의 모든 영속 상태를 정의한다. Hibernate에서, 그것은 그런 상속 계층"
"구조들을 명시적으로 매핑하는데 필수적이지 않다. 당신은 별도의 <literal>&lt;"
"class&gt;</literal> 선언을 가진 각각의 클래스를 간단히 매핑시킬 수 있다. 하지"
"만 당신이 다형성 연관관계들(예를 들면 당신의 계층구조의 슈퍼클래스에 대한 연"
"관)을 사용하고자 원할 경우, 당신은 <literal>&lt;union-subclass&gt;</literal> "
"매핑을 사용할 필요가 있다."

#. Tag: para
#, no-c-format
msgid ""
"No discriminator column or key column is required for this mapping strategy."
msgstr "이 매핑 방도에는 판별자 컬럼이나 키 컬럼이 필요하지 않다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Join"
msgstr "join"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Using the <literal>&lt;join&gt;</literal> element, it is possible to map "
"properties of one class to several tables that have a one-to-one "
"relationship. For example:"
msgstr ""
"<literal>&lt;join&gt;</literal>요소를 사용하면, 테이블들 사이에 1대일 관계가 "
"존재할 때, 하나의 클래스에 속한 프로퍼티들을 여러 테이블들로 매핑시키는 것이 "
"가능하다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>table</literal>: the name of the joined table."
msgstr "<literal>table</literal>: 조인된 테이블의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>join</literal>): "
"if set to <literal>join</literal>, the default, Hibernate will use an inner "
"join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its "
"superclasses. It will use an outer join for a <literal>&lt;join&gt;</"
"literal> defined by a subclass. If set to <literal>select</literal> then "
"Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> "
"defined on a subclass. This will be issued only if a row represents an "
"instance of the subclass. Inner joins will still be used to retrieve a "
"<literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr ""
"<literal>fetch</literal> (옵션 - 디폴트는 <literal>join</literal>): "
"<literal>join</literal>으로 설정될 경우, 디폴트로 Hibernate는 하나의 클래스 "
"또는 그것의 슈퍼 클래스들에 의해 정의된 <literal>&lt;join&gt;</literal>을 검"
"색하는데 inner join을 사용하고 서브클래스에 의해 정의된 <literal>&lt;join&gt;"
"</literal>을 검색하는데 outer join을 사용할 것이다. 만일 <literal>select</"
"literal>로 설정할 경우, Hibernate는 서브클래스 상에 정의된 <literal>&lt;"
"join&gt;</literal>에 대해 sequential select를 사용할 것이고, 그것은 한 행이 "
"서브클래스의 인스턴스를 표현하는 것으로 판명되는 경우에만 명령이 내려질 것이"
"다. inner join들은 여전히 클래스와 그것의 슈퍼클래스들에 의해 정의된 "
"<literal>&lt;join&gt;</literal>을 검색하는데 사용될 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>inverse</literal> (optional - defaults to <literal>false</"
"literal>): if enabled, Hibernate will not insert or update the properties "
"defined by this join."
msgstr ""
"<literal>inverse</literal> (옵션 - 디폴트는 <literal>false</literal>): 이용 "
"가능할 경우, Hibernate는 이 조인에 의해 정의된 프로퍼티들을 삽입시키거나 업데"
"이트하려고 시도하지 않을 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optional</literal> (optional - defaults to <literal>false</"
"literal>): if enabled, Hibernate will insert a row only if the properties "
"defined by this join are non-null. It will always use an outer join to "
"retrieve the properties."
msgstr ""
"<literal>optional</literal> (옵션 - 디폴트는 <literal>false</literal>): 이용 "
"가능할 경우, Hibernate는 이 조인에 의해 정의된 프로퍼티들이 null이 아닐 경우"
"에만 한 행을 삽입시킬 것이고 그 프로퍼티들을 검색하는데 outer join을 항상 사"
"용할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For example, address information for a person can be mapped to a separate "
"table while preserving value type semantics for all properties:"
msgstr ""
"예를 들어, (모든 프로퍼티들에 대해 value 타입 의미를 유지하면서) 개인의 주소 "
"정보는 별도의 테이블에 매핑될 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This feature is often only useful for legacy data models. We recommend fewer "
"tables than classes and a fine-grained domain model. However, it is useful "
"for switching between inheritance mapping strategies in a single hierarchy, "
"as explained later."
msgstr ""
"이 특징은 자주 리거시 데이터 모형들에 대해서만 유용하고, 우리는 클래스들과 "
"잘 정제된 도메인 모형 보다 더 적은 테이블들을 권장한다. 하지만 뒷 부분에 설명"
"되어 있듯이, 그것은 하나의 계층구조 내에 있는 상속 매핑 방도들 사이를 전환하"
"는 것에 유용하다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Key"
msgstr "key"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;key&gt;</literal> element has featured a few times within "
"this guide. It appears anywhere the parent mapping element defines a join to "
"a new table that references the primary key of the original table. It also "
"defines the foreign key in the joined table:"
msgstr ""
"우리는 지금까지 몇 번 나타났던 <literal>&lt;key&gt;</literal> 요소를 보았다. "
"그것은 부모 매핑 요소가 새로운 테이블에 대한 조인을 정의하는 어느 곳에서나 나"
"타나고, 그것은 조인된 테이블의 foreign 키를 정의하고, 그것은 원래의 테이블의 "
"프라이머리 키를 참조한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>on-delete</literal> (optional - defaults to <literal>noaction</"
"literal>): specifies whether the foreign key constraint has database-level "
"cascade delete enabled."
msgstr ""
"<literal>on-delete</literal> (옵션 - 디폴트는 <literal>noaction</literal>): "
"foreign key 컨스트레인트가 데이터베이스 레벨의 cascade delete를 사용가능하도"
"록 할